---
layout: single
title:  "20220608 백준 코테 연습 5문제"
categories: baekjoon
---

# 쉬운 계단 수
**문제**

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

**입력**

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

**출력**

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.


```python
def solution(n):
    dp = [[0]*10 for _ in range(n + 1)]
    dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

    for i in range(2, n + 1):
        for j in range(1, 9):
            dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1]
            dp[i][0] = dp[i-1][1]
            dp[i][9] = dp[i-1][8]

    return sum(dp[n])%1000000000
```

# 스티커

**문제**

상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.

모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.

위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

**입력**

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

**출력**

각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.


```python
def solution(n, stickers):
    dp = [[0] * n for _ in range(2)]
    dp[0][0] = stickers[0][0]
    dp[1][0] = stickers[1][0]
    dp[0][1] = stickers[1][0] + stickers[0][1]
    dp[1][1] = stickers[0][0] + stickers[1][1]

    y_list = [0, 1]
    for i in range(2, n):
        for j in range(2):
            k = y_list[j-1]
            dp[j][i] = max(stickers[j][i] + dp[k][i-1], stickers[j][i] + dp[k][i-2])
    answer = max(dp[0][-1], dp[1][-1])
    return answer
```

# 오르막 수
**문제**

오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.

예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.

수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.

**입력**

첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.

**출력**

첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.


```python
def solution(n):
    dp = [[0]*10 for _ in range(n + 1)]
    dp[1] = [1] * 10
    for i in range(2, n + 1):
        for j in range(10):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

    answer = sum(dp[n])
    return answer % 10007
```

# 동물원
**문제**

어떤 동물원에 가로로 두칸 세로로 N칸인 우리가 있다.

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

**입력**

첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

**출력**

첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.


```python
def solution(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 3

    for i in range(2, n + 1):
        dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % 9901

    return dp[n]

n = int(input())
print(solution(n))
```

# 점프

**문제**

N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.

각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.

**입력**

첫째 줄에 게임 판의 크기 N (4 ≤ N ≤ 100)이 주어진다. 그 다음 N개 줄에는 각 칸에 적혀져 있는 수가 N개씩 주어진다. 칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.

**출력**

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 문제의 규칙에 맞게 갈 수 있는 경로의 개수를 출력한다. 경로의 개수는 263-1보다 작거나 같다.


```python
def solution(n, maps):
    dp = [[0] * n for _ in range(n)]
    dp[0][0] = 1

    for i in range(n):
        for j in range(n):
            if i == j == n - 1:
                return dp[n - 1][n - 1]
            
            if dp[i][j] != 0 and i + maps[i][j] < n:
                dp[i + maps[i][j]][j] += dp[i][j]
                
            if dp[i][j] != 0 and j + maps[i][j] < n:
                dp[i][j + maps[i][j]] += dp[i][j]
```
