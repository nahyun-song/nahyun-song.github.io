---
layout: single
title:  "20211201 이것이 취업을 위한 코딩 테스트다/바닥 공사/효율적인 화폐 구성"
categories: coding_test
---

# 1. 바닥 공사

**문제 설명**
- 가로의 길이가 `N`, 세로의 길이가 2인 직사각형 형태의 얆은 바닥이 있다. 태일이는 이 얆은 바닥을 `1X2`의 덮개, `2X1`의 덮개, `2X2`의 덮개를 이용해 채우고자 한다.
- 이 때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오.

**입력 조건**
- 첫째 줄에 `N`이 주어진다. `(1<=N<=1,000)`

**출력 조건**
- 첫째 줄에 `2XN` 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

**내 풀이**


```python
N = int(input())

d = [0] * (N+1)

d[1] = 1
d[2] = 3

for i in range(3, N+1):
    d[i] = (d[i-1] + 2 * d[i-2]) % 796796 # 1X2타일 먼저 까는 경우의 수 : d[i-1], 2X1타일을 먼저 까는 경우의 수 d[i-2], 2X2타일을 먼저 까는 경우의 수 d[i-2]
    
print(d[N])
```

    20
    699051


**공식 풀이**


```python
# 정수 N을 입력 받기
n = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1001

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[1] = 1
d[2] = 3
for i in range(3, n + 1):
    d[i] = (d[i - 1] + 2 * d[i - 2]) % 796796

# 계산된 결과 출력
print(d[n])
```

    20
    699051


# 2. 효율적인 화폐 구성

**문제 설명**
- `N`가지 종류의 화폐가 있습니다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 `M`원이 되도록 하려고 합니다. 이떄 각 종류의 화폐는 몇 개라도 사용할 수 있습니다.
- 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수입니다.
- <u>`M`원을 만들기 위한 최소한의 화폐 개수</u>를 출력하는 프로그램을 작성하세요.

**입력 조건**
- 첫째 줄에 `N, M`이 주어진다. `(1<=N<=100, 1<=M<=10,000)`
- 이후의 `N`개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.

**출력 조건**
- 첫째 줄에 최소 화폐 개수를 출력한다.
- 불가능할 때는 -1을 출력한다.

**내 풀이**


```python
N, M = map(int, input().split())
N_list = []

for i in range(N):
    N_list.append(int(input()))
N_list.sort(reverse = True)
    
d = [0] * (M+1)
    
for i in range(1, M+1):
    if i in N_list :
        d[i] = 1 # i가 입력받은 수일 때 1
    elif i < min(N_list):
        d[i] = -1 # i가 입력받은 수의 최소값보다 작을 때 -1
    else:
        try :
            M_list = []
            for N in N_list:
                if (i-N >= min(N_list)) and (d[i-N] > 0) : # i 직전의 경우의 수 확인. i-N이 입력받은 수의 최솟값보다 작으면 범위를 벗어남
                                                           ## d[i-N] > 0 : 직전 경우의 수 가 있는 경우
                    M_list.append(d[i-N])
            assert len(M_list) > 0 # 직전 경우의 수가 있는지 없는지 확인
        except :
            d[i] = -1 # 직전 경우의 수가 없는 경우
        else :
            d[i] = min(M_list) + 1 # 직전 경우의 수가 있는 경우. 경우의 수들의 최솟값 + 1
    
print(d[M])
```

    3 31
    5
    7
    8
    4


**공식 풀이**


```python
	# 정수 N, M을 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력 받기
array = []
for i in range(n):
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001: # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])

```

    3 31
    5
    7
    8
    4

