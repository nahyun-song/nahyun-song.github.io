---
layout: single
title:  "20211015 이것이 취업을 위한 코딩 테스트다/큰 수의 법칙/숫자 카드 게임"
categories: coding_test
---


## 1. 큰 수의 법칙

**문제 설명**\
배열의 크기 `N`, 숫자가 더해지는 횟수 `M`, 연속해서 더할 수 있는 최대값 `K`가 주어질 때, 큰 수의 법칙에 따라 더해진 답을 출력하시오.\
\
큰 수의 법칙 : 입력된 배열에서 특정 인덱스의 수를 최대 `K`번 반복하여 더할 수 있고 `K`번 초과하여 더하면 안된다.\
ex)`N=5, M=8, K=3`\
   주어진 배열 : `[2, 4, 5, 4, 6]`\
   최댓값 : 6+6+6+5+6+6+6+5=46\
\
**입력 조건**
- 첫째 줄에 `N(2<=N<=1,000), M(1<=M<=10,000), K(1<=K<=10,000)`의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
- 둘째 줄에 `N`개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10,000이하의 수로 주어진다.
- 입력으로 주어지는 `K`는 항상 `M`보다 작거나 같다.

**출력 조건**
- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.


```python
#입력
N, M, K = map(int, input().split()) #N, M, K 입력받고 공백을 기준으로 나누어 매핑
num_list = list(map(int, input().split())) #숫자 배열을 입력받아 자연수 배열로 리스트에 저장

num_list.sort() #리스트 안의 최댓값을 찾기 위해 오름차순 정렬
n1 = num_list.pop() #가장 큰 값 n1에 저장
n2 = num_list.pop() #남은 숫자 중 가장 큰 값 n2에 저장

n3 = M // (K + 1) #몇 번 반복되는지 구하기
n4 = M % (K + 1) #반복되고 남은 횟수 구하기

result = (((n1 * K) + n2) * n3) + (n1 * n4)

#출력
print(result)
```

    5 8 3
    2 4 5 4 6
    46


## 2. 숫자 카드 게임

**문제 설명**
1. 숫자가 쓰인 카드들이 `NxM` 형태로 놓여 있다. 이 때 `N`은 행의 개수를 의미하며, `M`은 열의 개수를 의미한다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 그 다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

**입력 조건**
- 첫째 줄에 숫자 카드들이 놓인 행의 개수 `N`과 열의 개수 `M`이 공백을 기준으로 하여 각각 자연수로 주어진다. `(1<=N,M<=100)`
- 둘째 줄부터 `N`개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1이상 10,000이하의 자연수이다.

**출력 조건**
- 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.


```python
#입력
N, M = map(int, input().split()) #N, M 입력받고 공백을 기준으로 나누어 매핑

min_list = [] #각 행의 최솟값을 뽑아 넣을 리스트

for i in range(N):
    num_list = list(map(int, input().split())) #한 행씩 입력받기
    min_list.append(min(num_list)) #최솟값을 뽑아 리스트에 넣기

result = max(min_list) #최댓값 추출

#출력
print(result)
```

    4 3
    1 3 3
    3 1 2
    4 1 4
    2 2 2
    2

